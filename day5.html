<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Actors and actor isolation (@MainActor) | Swift September</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="./styles.css" />
    <meta name="description" content="Swift September – Day 5: Actors and actor isolation (@MainActor)" />
  </head>
  <body class="day">
    <main class="page-grid">
      <aside class="left-rail">
        <div class="floating-cover" aria-hidden="true"></div>
      </aside>

      <div class="day-content">
        <nav class="breadcrumbs" aria-label="Breadcrumb">
        <ul><li>Day 5</li></ul>
      	</nav>

        <div class="day-hero">
          <h1>Actors and actor isolation (@MainActor)</h1>
        </div>

        <div class="author-row">
          <img
            src="./images/profilePic.png"
            alt="Author"
            class="author-avatar"
            width="40"
            height="40"
            loading="lazy"
          />
          <div class="author-name">
            <strong>Matheus Z. Andrade</strong> | iOS Engineer
          </div>
          <div class="author-line" aria-hidden="true"></div>
        </div>

        <!-- 1) Introduction (mandatory, first) -->
        <section class="section">
          <h2 data-title="Introduction">Introduction</h2>
          <p>Managing concurrency safely in Swift can be tricky — but that’s where actors and <code>@MainActor</code> come in. They provide a structured way to protect shared state and ensure UI code always runs on the main thread. In this article, we’ll break down how actors work, why actor isolation matters, and how <code>@MainActor</code> integrates into your iOS apps.</p>
        </section>

        <!-- 2) Topic sections -->
        <section class="section">
          <h2 data-title="Actors prevent data races">Actors prevent data races</h2>
          <p>Actors are reference types designed to guarantee mutual exclusion. Only one task at a time can touch their stored properties, which makes them perfect for protecting shared state.</p>
          <div class="codebox" role="region" aria-label="Swift example: simple actor">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>actor Counter {
  private var value = 0

  func increment() {
    value += 1
  }

  func getValue() -> Int {
    value
  }
}</code></pre>
          </div>
          <p>This ensures that two tasks can’t modify <code>value</code> at the same time.</p>
        </section>

        <section class="section">
          <h2 data-title="Awaiting actor access">Awaiting actor access</h2>
          <p>When you call methods or access properties from outside the actor, you usually need <code>await</code>. This enforces safe, asynchronous boundaries.</p>
          <div class="codebox" role="region" aria-label="Swift example: calling an actor method">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>let counter = Counter()

Task {
  await counter.increment()
  let total = await counter.getValue()
  print("Total: \(total)")
}</code></pre>
          </div>
          <p>By awaiting, you give Swift a chance to schedule access safely.</p>
        </section>

        <section class="section">
          <h2 data-title="@MainActor for UI updates">@MainActor for UI updates</h2>
          <p><code>@MainActor</code> is a special actor that ensures code runs on the main thread. It’s critical for UIKit and SwiftUI updates, where UI must always be updated from the main thread.</p>
          <div class="codebox" role="region" aria-label="Swift example: using MainActor for UI">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>@MainActor
func updateLabel(_ label: UILabel, text: String) {
  label.text = text
}</code></pre>
          </div>
          <p>Any code marked with <code>@MainActor</code> will be executed on the main thread, ensuring thread-safety for UI operations.</p>
        </section>

        <section class="section">
          <h2 data-title="Common pitfalls">Common pitfalls</h2>
          <ul>
            <li><strong>Forgetting <code>await</code></strong>: Attempting to call an actor method without <code>await</code> won’t compile.</li>
            <li><strong>Blocking the main thread</strong>: Even with <code>@MainActor</code>, avoid long-running tasks on the main thread.</li>
            <li><strong>Mixing old concurrency APIs</strong>: Try not to mix GCD <code>DispatchQueue.main</code> with <code>@MainActor</code>. Stick to structured concurrency.</li>
          </ul>
        </section>

        <!-- 3) Conclusion (mandatory) -->
        <section class="section">
          <h2 data-title="Conclusion">Conclusion</h2>
          <p>Actors give us a safe way to manage shared state by ensuring mutual exclusion. The <code>@MainActor</code> attribute guarantees that UI code always runs on the main thread. Together, they make Swift concurrency safer and more predictable, especially for iOS apps where UI correctness is critical.</p>
        </section>

        <!-- 4) Next steps (mandatory, last) -->
        <section class="section" style="margin-bottom: 40px;">
          <h2 data-title="Next steps">Next steps</h2>
          <p>Try creating your own actor to manage a shared resource, and then annotate a function with <code>@MainActor</code> to handle UI updates. Pay attention to when you need <code>await</code> and how Swift enforces safe access rules.</p>
          <ul>
            <li><a href="https://developer.apple.com/documentation/swift/actor" target="_blank" rel="noopener">Apple reference: Actor — Apple Docs</a></li>
            <li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/#Actors" target="_blank" rel="noopener">Actors — The Swift Programming Language</a></li>
          </ul>
        </section>
      </div>

      <nav class="right-rail">
        <div class="floating-menu">
          <ul id="toc"></ul>
        </div>
      </nav>
    </main>

    <script src="./main.js" defer></script>
  </body>
</html>
