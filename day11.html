<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Interop: SwiftUI + UIKit (UIHostingController, UIViewRepresentable/UIViewControllerRepresentable) | Swift September</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="./styles.css" />
    <meta name="description" content="Swift September – Day 11: Interop: SwiftUI + UIKit (UIHostingController, UIViewRepresentable/UIViewControllerRepresentable)" />
  </head>
  <body class="day">
    <main class="page-grid">
      <aside class="left-rail">
        <div class="floating-cover" aria-hidden="true"></div>
      </aside>

      <div class="day-content">
        <nav class="breadcrumbs" aria-label="Breadcrumb">
        <ul><li>Day 11</li></ul>
      	</nav>

        <div class="day-hero">
          <h1>Interop: SwiftUI + UIKit </h1>
        </div>

        <div class="author-row">
          <img
            src="./images/profilePic.png"
            alt="Author"
            class="author-avatar"
            width="40"
            height="40"
            loading="lazy"
          />
          <div class="author-name">
            <strong>Matheus Z. Andrade</strong> | iOS Engineer
          </div>
          <div class="author-line" aria-hidden="true"></div>
        </div>

        <!-- 1) Introduction (mandatory, first) -->
        <section class="section">
          <h2 data-title="Introduction">Introduction</h2>
          <p>SwiftUI and UIKit don’t have to live in separate worlds. Apple gave us powerful tools to bridge them so we can adopt SwiftUI incrementally or reuse battle-tested UIKit components inside modern SwiftUI code. Today we’ll explore <code>UIHostingController</code>, <code>UIViewRepresentable</code>, and <code>UIViewControllerRepresentable</code>—the main building blocks of interoperability.</p>
        </section>

        <!-- 2) Topic sections -->
        <section class="section">
          <h2 data-title="Embedding SwiftUI in UIKit">Embedding SwiftUI in UIKit with UIHostingController</h2>
          <p><code>UIHostingController</code> lets you wrap any SwiftUI view and drop it into an existing UIKit hierarchy. This is the most common way to experiment with SwiftUI inside a UIKit app.</p>
          <div class="codebox" role="region" aria-label="Swift example: UIHostingController basic usage">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>let swiftUIView = MyView()
let hostingVC = UIHostingController(rootView: swiftUIView)
‎
// Add to a UINavigationController stack
navigationController?.pushViewController(hostingVC, animated: true)</code></pre>
          </div>
          <p>Best practice: inject dependencies through the SwiftUI view’s initializer, not by mutating after creation. For dynamic sizing (e.g. table cells), use <code>hostingController.sizingOptions = .intrinsicContentSize</code>.</p>
        </section>

        <section class="section">
          <h2 data-title="Wrapping UIKit views">Wrapping UIKit views with UIViewRepresentable</h2>
          <p><code>UIViewRepresentable</code> allows you to take any UIKit view and make it available in SwiftUI. This is especially useful for components like <code>UITextField</code> or <code>UISlider</code> that aren’t easily replaced yet.</p>
          <div class="codebox" role="region" aria-label="Swift example: UITextField wrapped in SwiftUI">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>struct TextFieldWrapper: UIViewRepresentable {
    @Binding var text: String
‎
    func makeUIView(context: Context) -> UITextField {
        let textField = UITextField()
        textField.delegate = context.coordinator
        return textField
    }
‎
    func updateUIView(_ uiView: UITextField, context: Context) {
        uiView.text = text
    }
‎
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
‎
    class Coordinator: NSObject, UITextFieldDelegate {
        var parent: TextFieldWrapper
        init(_ parent: TextFieldWrapper) { self.parent = parent }

        func textFieldDidChangeSelection(_ textField: UITextField) {
            parent.text = textField.text ?? ""
        }
    }
}</code></pre>
          </div>
          <p>Keep state in SwiftUI with <code>@Binding</code>. UIKit just reflects and reports changes back up.</p>
        </section>

        <section class="section">
          <h2 data-title="Wrapping view controllers">Wrapping view controllers with UIViewControllerRepresentable</h2>
          <p>When you need to use a UIKit controller such as <code>UIImagePickerController</code> or <code>SFSafariViewController</code>, use <code>UIViewControllerRepresentable</code>.</p>
          <div class="codebox" role="region" aria-label="Swift example: Safari view controller in SwiftUI">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>import SafariServices
import SwiftUI
‎
struct SafariView: UIViewControllerRepresentable {
    let url: URL

    func makeUIViewController(context: Context) -> SFSafariViewController {
        SFSafariViewController(url: url)
    }

    func updateUIViewController(_ uiViewController: SFSafariViewController, context: Context) {
        // No update needed here
    }
}</code></pre>
          </div>
          <p>You can present it with <code>.sheet</code> or <code>.fullScreenCover</code>. Use a <code>Coordinator</code> for delegate callbacks when needed.</p>
        </section>

        <section class="section">
          <h2 data-title="Sizing and layout gotchas">Sizing and layout gotchas</h2>
          <p>When embedding UIKit in SwiftUI, implement <code>intrinsicContentSize</code> or use <code>systemLayoutSizeFitting</code> to get correct sizing. When embedding SwiftUI in UIKit, use Auto Layout with constraints and set <code>view.translatesAutoresizingMaskIntoConstraints = false</code>.</p>
        </section>

        <section class="section">
          <h2 data-title="State and data flow">State and data flow</h2>
          <p>Always keep a single source of truth. If UIKit owns the state, expose it as an <code>ObservableObject</code> and inject into SwiftUI with <code>.environmentObject</code>. If SwiftUI owns the state, push updates down via <code>updateUIView</code> or <code>updateUIViewController</code> instead of duplicating state in the wrapper.</p>
        </section>

        <!-- 3) Conclusion (mandatory) -->
        <section class="section">
          <h2 data-title="Conclusion">Conclusion</h2>
          <p>Bridging SwiftUI and UIKit means you don’t have to choose one or the other. You can modernize your app step by step, adopting SwiftUI for new screens while keeping reliable UIKit components where needed. With the right patterns for state, layout, and delegation, the two frameworks can live in harmony.</p>
        </section>

        <!-- 4) Next steps (mandatory, last) -->
        <section class="section" style="margin-bottom: 40px;">
          <h2 data-title="Next steps">Next steps</h2>
          <p>Try wrapping a small UIKit control into SwiftUI, or embed a SwiftUI component in an existing UIKit screen. Keep an eye on how state flows and how layout adapts. Once you’re comfortable, experiment with lifecycle-driven controllers like <code>SFSafariViewController</code>.</p>
          <ul>
            <li><a href="https://developer.apple.com/documentation/swiftui/uihostingcontroller" target="_blank" rel="noopener">UIHostingController — Apple Docs</a></li>
            <li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols/" target="_blank" rel="noopener">Protocols — The Swift Programming Language</a></li>
          </ul>
        </section>
      </div>

      <nav class="right-rail">
        <div class="floating-menu">
          <ul id="toc"></ul>
        </div>
      </nav>
    </main>

    <script src="./main.js" defer></script>
  </body>
</html>
