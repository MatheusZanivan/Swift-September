<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Optionals, Generics, and Protocol-Oriented Programming | Swift September</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="./styles.css" />
  <meta name="description" content="Swift September – Day 2: Optionals, Generics, and Protocol-Oriented Programming" />
</head>

<body class="day">
  <main class="page-grid">
    <aside class="left-rail">
      <div class="floating-cover" aria-hidden="true"></div>
    </aside>
    <div class="day-content">
      <nav class="breadcrumbs" aria-label="Breadcrumb">
        <ul></ul>
      </nav>
      <div class="day-hero">
        <h1>Optionals, Generics, and Protocol-Oriented Programming</h1>
      </div>

      <div class="author-row">
        <img src="./images/profilePic.png" alt="Author" class="author-avatar" width="40" height="40" loading="lazy" />
        <div class="author-name">
          <strong>Matheus Z. Andrade</strong> | iOS Engineer
        </div>
        <div class="author-line" aria-hidden="true"></div>
      </div>

      <!-- 1) Introduction -->
      <section class="section">
        <h2 data-title="Introduction">Introduction</h2>
        <p>Swift’s true strength comes from a few core concepts that shape how we design modern applications: Optionals, Generics, and Protocol-Oriented Programming (POP). Together, they allow us to write code that is safer, more reusable, and easier to scale. Optionals help us handle the absence of values without crashes, Generics let us abstract behavior across multiple types without duplication, and POP encourages flexible composition instead of rigid inheritance. Understanding these pillars is essential for building clean, maintainable, and expressive Swift code.</p>
      </section>

      <!-- 2) Topics -->
      <section class="section">
        <h2 data-title="Optionals">Optionals</h2>
        <p>Optionals let us represent “value or no value” safely. Instead of crashing when data is missing, Swift makes
          us handle the absence explicitly. This leads to more predictable code and fewer runtime surprises.</p>
        <div class="codebox" role="region" aria-label="Swift example: optional binding">
          <button class="codebox-copy" type="button" aria-label="Copy code">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white"
                stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
              <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6"
                stroke-linecap="round" stroke-linejoin="round" />
            </svg>
          </button>
          <div class="codebox-toast">Copied</div>
          <pre><code>// Example: Optional binding
‎ 
let number: Int? = Int("42")
‎ 
if let value = number {
  print("Converted: (value)")
} else {
  print("Not a valid number")
}</code></pre>
        </div>
        <h3>Common pitfalls</h3>
        <p>Avoid force unwrapping (<code>!</code>) unless you are 100% sure a value exists. Prefer <code>if let</code>,
          <code>guard let</code>, or optional chaining.
        </p>
      </section>

      <section class="section">
        <h2 data-title="Generics">Generics</h2>
        <p>Generics make code reusable by abstracting over types. Instead of writing the same logic for multiple types,
          we write it once and let Swift fill in the details.</p>
        <div class="codebox" role="region" aria-label="Swift example: generic function">
          <button class="codebox-copy" type="button" aria-label="Copy code">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white"
                stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
              <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6"
                stroke-linecap="round" stroke-linejoin="round" />
            </svg>
          </button>
          <div class="codebox-toast">Copied</div>
          <pre><code>// Example: Generic swap function
‎ 
func swapValues<T>(\_ a: inout T, \_ b: inout T) {
  let temp = a
  a = b
  b = temp
}

var x = "Hello"
var y = "World"
swapValues(\&x, \&y)
‎ 
print(x, y) // "World Hello"</code></pre>
        </div>
        <p>Generics keep our APIs type-safe while avoiding duplication. They are the foundation of many Swift standard
          library features like <code>Array</code> and <code>Dictionary</code>.</p>
      </section>

      <section class="section">
        <h2 data-title="Protocol-Oriented Programming">Protocol-Oriented Programming</h2>
        <p>POP is about describing capabilities rather than forcing class hierarchies. With protocols and extensions, we
          can share behaviors flexibly across types.</p>
        <div class="codebox" role="region" aria-label="Swift example: protocol with extension">
          <button class="codebox-copy" type="button" aria-label="Copy code">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white"
                stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" />
              <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6"
                stroke-linecap="round" stroke-linejoin="round" />
            </svg>
          </button>
          <div class="codebox-toast">Copied</div>
          <pre><code>// Example: Protocol and extension
‎ 
protocol Describable {
  var description: String { get }
}

extension Describable {
  func printDescription() {
    print(description)
  }
}

struct User: Describable {
  let name: String
  var description: String { "User: (name)" }
}
‎ 
User(name: "Alice").printDescription()</code></pre>
        </div>
        <p>This approach emphasizes composition, which keeps systems modular and easier to test compared to deep class
          inheritance.</p>
      </section>

      <!-- 3) Conclusion -->
      <section class="section">
        <h2 data-title="Conclusion">Conclusion</h2>
        <p>Optionals keep us safe, Generics keep us flexible, and Protocol-Oriented Programming keeps us modular.
          Mastering these three concepts unlocks much of Swift’s expressive power and allows us to write code that is
          both elegant and robust.</p>
      </section>

      <!-- 4) Next steps -->
      <section class="section" style="margin-bottom: 40px;">
        <h2 data-title="Next steps">Next steps</h2>
        <p>Try practicing by writing a generic function that works on both <code>Array</code> and <code>Set</code>, or
          by defining a new protocol and applying it to an existing type in your project. Explore Apple’s official
          resources to deepen your knowledge:</p>
        <ul>
          <li><a href="https://developer.apple.com/swift/" target="_blank" rel="noopener">Swift — Apple Docs</a></li>
          <li><a href="https://developer.apple.com/documentation/swift/optional" target="_blank"
              rel="noopener">Optionals — Apple Docs</a></li>
          <li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols/" target="_blank"
              rel="noopener">Protocols — The Swift Programming Language</a></li>
        </ul>
      </section>
    </div>

    <nav class="right-rail">
      <div class="floating-menu">
        <ul id="toc"></ul>
      </div>
    </nav>
  </main>

  <script src="./main.js" defer></script>

</body>

</html>