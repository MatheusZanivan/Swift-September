<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Architecture patterns (MVC, MVVM, VIPER, Clean, Coordinator) | Swift September</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="./styles.css" />
    <meta name="description" content="Swift September – Day 17: Architecture patterns (MVC, MVVM, VIPER, Clean, Coordinator)" />
  </head>
  <body class="day">
    <main class="page-grid">
      <aside class="left-rail">
        <div class="floating-cover" aria-hidden="true"></div>
      </aside>

      <div class="day-content">
        <nav class="breadcrumbs" aria-label="Breadcrumb">
        <ul><li>Day 17</li></ul>
      	</nav>

        <div class="day-hero">
          <h1>Architecture patterns (MVC, MVVM, VIPER, Clean, Coordinator)</h1>
        </div>

        <div class="author-row">
          <img
            src="./images/profilePic.png"
            alt="Author"
            class="author-avatar"
            width="40"
            height="40"
            loading="lazy"
          />
          <div class="author-name">
            <strong>Matheus Z. Andrade</strong> | iOS Engineer
          </div>
          <div class="author-line" aria-hidden="true"></div>
        </div>

        <!-- 1) Introduction -->
        <section class="section">
          <h2 data-title="Introduction">Introduction</h2>
          <p>
            The way you structure an iOS app directly influences testability, scalability, and how fast your team can ship features. 
            iOS has a rich history of architecture patterns, from simple MVC to Clean Architecture and Coordinators. 
            Each pattern has trade-offs: some are fast to start but harder to maintain, others are rigorous but slower to bootstrap. 
            Let’s explore the most common approaches and when they shine.
          </p>
        </section>

        <!-- 2) Topic sections -->
        <section class="section">
          <h2 data-title="MVC">Model–View–Controller (MVC)</h2>
          <p>
            MVC is the default pattern in iOS projects. It’s simple to set up: 
            Views handle UI, Controllers coordinate, and Models represent data. 
            The biggest risk is ending up with “Massive View Controllers.”
          </p>
          <div class="codebox" role="region" aria-label="Swift example: simple MVC">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>// Model
struct Task {
    let title: String
    var done: Bool
}
‎
// Controller
class TaskViewController: UIViewController {
    var task = Task(title: "Buy milk", done: false)
    
    @IBOutlet weak var titleLabel: UILabel!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        titleLabel.text = task.title
    }
}
</code></pre>
          </div>
          <h3>Common pitfall</h3>
          <p>
            Don’t push all business logic into the ViewController. Use dedicated services or managers to avoid massive files.
          </p>
        </section>

        <section class="section">
          <h2 data-title="MVVM">Model–View–ViewModel (MVVM)</h2>
          <p>
            MVVM fits naturally with SwiftUI and Combine. 
            The ViewModel exposes state and transforms inputs into outputs, while the View binds to published properties.
          </p>
          <div class="codebox" role="region" aria-label="Swift example: SwiftUI with MVVM">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>class TaskViewModel: ObservableObject {
    @Published var task = Task(title: "Buy milk", done: false)
    
    func toggle() {
        task.done.toggle()
    }
}
‎
struct TaskView: View {
    @StateObject var vm = TaskViewModel()
    
    var body: some View {
        VStack {
            Text(vm.task.title)
            Button("Toggle", action: vm.toggle)
        }
    }
}
</code></pre>
          </div>
          <h3>Best practice</h3>
          <p>
            Keep UIKit or SwiftUI details out of the ViewModel. It should expose only pure state and logic.
          </p>
        </section>

        <section class="section">
          <h2 data-title="VIPER">VIPER</h2>
          <p>
            VIPER divides responsibilities into five layers: View, Interactor, Presenter, Entity, and Router. 
            It maximizes testability and separation of concerns, at the cost of boilerplate. 
            Best suited for large features or teams that need strict boundaries.
          </p>
          <div class="codebox" role="region" aria-label="Swift example: VIPER presenter">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>protocol TaskView: AnyObject {
    func show(title: String)
}
‎
class TaskPresenter {
    weak var view: TaskView?
    private let interactor: TaskInteractor
    
    init(interactor: TaskInteractor) {
        self.interactor = interactor
    }
    
    func viewDidLoad() {
        let task = interactor.fetchTask()
        view?.show(title: task.title)
    }
}
</code></pre>
          </div>
        </section>

        <section class="section">
          <h2 data-title="Clean Architecture">Clean Architecture</h2>
          <p>
            Clean Architecture organizes code into Presentation, Domain, and Data layers. 
            Each layer depends inward on abstract interfaces, not concrete implementations. 
            It takes longer to set up but pays off in long-term maintainability.
          </p>
          <div class="codebox" role="region" aria-label="Swift example: Clean use case">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>// Domain layer
protocol TaskRepository {
    func fetchTask() -> Task
}
‎
struct GetTaskUseCase {
    let repository: TaskRepository
    func execute() -> Task {
        repository.fetchTask()
    }
}
</code></pre>
          </div>
        </section>

        <section class="section">
          <h2 data-title="Coordinator">Coordinator</h2>
          <p>
            Coordinators extract navigation from ViewControllers into dedicated objects. 
            This keeps controllers lean and makes deep-linking or complex flows easier. 
            The danger is ending up with one giant “God Coordinator” — compose smaller child coordinators instead.
          </p>
          <div class="codebox" role="region" aria-label="Swift example: simple coordinator">
            <button class="codebox-copy" type="button" aria-label="Copy code">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M9 9h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2Z" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 15H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v1" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <div class="codebox-toast">Copied</div>
            <pre><code>protocol Coordinator {
    func start()
}
‎
class AppCoordinator: Coordinator {
    let window: UIWindow
    init(window: UIWindow) { self.window = window }
    
    func start() {
        let vc = TaskViewController()
        window.rootViewController = UINavigationController(rootViewController: vc)
        window.makeKeyAndVisible()
    }
}
</code></pre>
          </div>
        </section>

        <!-- 3) Conclusion -->
        <section class="section">
          <h2 data-title="Conclusion">Conclusion</h2>
          <p>
            There’s no one-size-fits-all architecture. 
            MVC is great for quick prototypes, MVVM shines with SwiftUI, VIPER enforces discipline in large modules, Clean ensures long-term maintainability, and Coordinators improve navigation. 
            The key is choosing the right pattern for the scale and needs of your app.
          </p>
        </section>

        <!-- 4) Next steps -->
        <section class="section" style="margin-bottom: 40px;">
          <h2 data-title="Next steps">Next steps</h2>
          <p>
            Try building the same small feature (like a to-do list) using two different patterns. 
            Notice how testability, navigation, and code organization feel. 
            For further reading, check out Apple’s official guidance on app architecture and Swift fundamentals.
          </p>
          <ul>
            <li><a href="https://developer.apple.com/documentation/swift" target="_blank" rel="noopener">Swift — Apple Docs</a></li>
            <li><a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/" target="_blank" rel="noopener">Official Documentation - The Swift Programming Language</a></li>
          </ul>
        </section>
      </div>

      <nav class="right-rail">
        <div class="floating-menu">
          <ul id="toc"></ul>
        </div>
      </nav>
    </main>

    <script src="./main.js" defer></script>
  </body>
</html>
